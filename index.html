<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<title>Frame Hole Mask Editor</title>

<style>
body{
  background:#111;
  color:#fff;
  font-family:Arial;
  padding:20px;
}
button{
  margin:4px 4px 10px 0;
  padding:6px 12px;
  border:none;
  border-radius:6px;
  background:#4caf50;
  cursor:pointer;
  font-weight:bold;
}
canvas{
  background:
    repeating-conic-gradient(#555 0% 25%, #444 0% 50%)
    50% / 20px 20px;
  border-radius:12px;
}
</style>
</head>

<body>

<h3>Frame PNG â€“ Hole Mask Editor</h3>

<input type="file" id="frameInput" accept="image/*"><br><br>

<button id="resetBtn">RESET PATH</button>
<button id="saveBtn">SAVE FRAME PNG</button>

<br><br>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const frameInput = document.getElementById('frameInput');
const resetBtn = document.getElementById('resetBtn');
const saveBtn = document.getElementById('saveBtn');

let frame = new Image();

let points = [];
let closed = false;
let dragIndex = -1;
let hoverIndex = -1;

const R = 7;
const CLOSE_DIST = 10;

/* ===== LOAD FRAME ===== */
frameInput.onchange = e=>{
  const r = new FileReader();
  r.onload = ()=> frame.src = r.result;
  r.readAsDataURL(e.target.files[0]);
};

frame.onload = ()=>{
  canvas.width = frame.width;
  canvas.height = frame.height;
  draw();
};

/* ===== RESET ===== */
resetBtn.onclick = ()=>{
  points = [];
  closed = false;
  draw();
};

/* ===== SAVE CLEAN FRAME ===== */
saveBtn.onclick = ()=>{
  if(!closed || points.length < 3){
    alert('Path hole belum tertutup');
    return;
  }

  const out = document.createElement('canvas');
  out.width = canvas.width;
  out.height = canvas.height;
  const octx = out.getContext('2d');

  /* FRAME */
  octx.drawImage(frame,0,0);

  /* HOLE (TRANSPARENT) */
  octx.save();
  octx.globalCompositeOperation = 'destination-out';
  octx.beginPath();
  points.forEach((p,i)=>{
    if(i===0) octx.moveTo(p.x,p.y);
    else octx.lineTo(p.x,p.y);
  });
  octx.closePath();
  octx.fill();
  octx.restore();

  const link = document.createElement('a');
  link.download = 'frame_hole.png';
  link.href = out.toDataURL('image/png');
  link.click();
};

/* ===== DRAW EDITOR ===== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(frame.src){
    ctx.drawImage(frame,0,0);
  }

  /* HOLE PREVIEW */
  if(closed && points.length>=3){
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    points.forEach((p,i)=>{
      if(i===0) ctx.moveTo(p.x,p.y);
      else ctx.lineTo(p.x,p.y);
    });
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  /* PATH */
  if(points.length){
    ctx.strokeStyle = '#00e5ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    points.forEach((p,i)=>{
      if(i===0) ctx.moveTo(p.x,p.y);
      else ctx.lineTo(p.x,p.y);
    });
    if(closed) ctx.closePath();
    ctx.stroke();
  }

  /* POINTS */
  points.forEach((p,i)=>{
    ctx.fillStyle = (i===hoverIndex ? '#ff5252' : '#fff');
    ctx.beginPath();
    ctx.arc(p.x,p.y,R,0,Math.PI*2);
    ctx.fill();
  });
}

/* ===== HIT TEST ===== */
function hitPoint(x,y){
  return points.findIndex(p=>Math.hypot(p.x-x,p.y-y)<=R);
}

/* ===== MOUSE ===== */
canvas.onmousedown = e=>{
  const x = e.offsetX;
  const y = e.offsetY;

  const hit = hitPoint(x,y);
  if(hit !== -1){
    dragIndex = hit;
    return;
  }

  if(closed) return;

  if(points.length >= 3){
    const p0 = points[0];
    if(Math.hypot(p0.x-x,p0.y-y) < CLOSE_DIST){
      closed = true;
      draw();
      return;
    }
  }

  points.push({x,y});
  draw();
};

canvas.onmousemove = e=>{
  const x = e.offsetX;
  const y = e.offsetY;

  hoverIndex = hitPoint(x,y);

  if(dragIndex !== -1){
    points[dragIndex].x = x;
    points[dragIndex].y = y;
  }

  draw();
};

canvas.onmouseup = ()=> dragIndex = -1;
</script>

</body>
</html>
