<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Editor Bingkai Foto PNG Transparan</title>
  <style>
    body{
      font-family: Arial, sans-serif;
      background:#111;
      color:#fff;
      margin:0;
      padding:20px;
    }
    h1{font-size:22px;}
    .container{
      display:grid;
      grid-template-columns: 300px 1fr;
      gap:20px;
    }
    .panel{
      background:#1c1c1c;
      border-radius:10px;
      padding:15px;
    }
    label{display:block;margin-top:10px;font-size:14px;}
    input[type=file]{width:100%;margin-top:5px;}
    button{
      margin-top:15px;
      width:100%;
      padding:10px;
      border:none;
      border-radius:6px;
      background:#4caf50;
      color:#000;
      font-weight:bold;
      cursor:pointer;
    }
    canvas{
      width:100%;
      background: repeating-conic-gradient(#555 0% 25%, #444 0% 50%)
        50% / 20px 20px;
      border-radius:10px;
    }
  </style>
</head>
<body>

<h1>üñºÔ∏è Editor Bingkai Foto PNG Transparan</h1>
<p>Tujuan: membuat bingkai foto dengan bagian tengah transparan (tempat drop foto).</p>

<div class="container">
  <!-- PANEL KONTROL -->
  <div class="panel">
    <label>Upload Bingkai Foto</label>
    <input type="file" id="frameInput" accept="image/*" />

    <label>Mode Lubang</label>
    <select id="mode">
      <option value="manual">Manual (geser mouse)</option>
      <option value="center">Otomatis Tengah (Simple)</option>
      <option value="auto">Auto Detect Warna Tengah (Profesional)</option>
    </select>

    <label>Bentuk Lubang</label>
    <select id="shape">
      <option value="rect">Persegi</option>
      <option value="circle">Lingkaran</option>
    </select>

    <button id="downloadBtn">Download PNG Transparan</button>
  </div>

  <!-- CANVAS -->
  <div class="panel">
    <canvas id="canvas"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const frameInput = document.getElementById('frameInput');
const modeSelect = document.getElementById('mode');
const shapeSelect = document.getElementById('shape');
const downloadBtn = document.getElementById('downloadBtn');

let frameImage = new Image();

frameInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    frameImage.src = reader.result;
  };
  reader.readAsDataURL(file);
});

frameImage.onload = () => {
  canvas.width = frameImage.width;
  canvas.height = frameImage.height;
  redraw();
};

modeSelect.onchange = redraw;
shapeSelect.onchange = redraw;

let hole = { x:0, y:0, w:300, h:300, dragging:false };

function autoDetectHole(){
  // Menggunakan flood fill dari titik tengah untuk mendeteksi area lubang yang terhubung
  // Asumsikan area lubang adalah area dengan warna seragam (termasuk putih, arsiran, dll.) yang terhubung dari tengah
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const data = imgData.data;
  const visited = new Array(canvas.width * canvas.height).fill(false);
  const cx = Math.floor(canvas.width / 2);
  const cy = Math.floor(canvas.height / 2);
  const startIdx = (cy * canvas.width + cx) * 4;
  const baseColor = [data[startIdx], data[startIdx+1], data[startIdx+2], data[startIdx+3]];
  const tol = 30; // Toleransi warna, bisa disesuaikan

  let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
  const stack = [[cx, cy]];

  while (stack.length > 0) {
    const [x, y] = stack.pop();
    const idx = (y * canvas.width + x) * 4;
    if (visited[y * canvas.width + x] || 
        Math.abs(data[idx] - baseColor[0]) > tol || 
        Math.abs(data[idx+1] - baseColor[1]) > tol || 
        Math.abs(data[idx+2] - baseColor[2]) > tol || 
        Math.abs(data[idx+3] - baseColor[3]) > tol) {
      continue;
    }
    visited[y * canvas.width + x] = true;
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);

    // Tambahkan tetangga
    if (x > 0) stack.push([x-1, y]);
    if (x < canvas.width - 1) stack.push([x+1, y]);
    if (y > 0) stack.push([x, y-1]);
    if (y < canvas.height - 1) stack.push([x, y+1]);
  }

  return {x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1};
}

function redraw(){
  if(!frameImage.src) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(frameImage,0,0);

  let x,y,w,h;
  if(modeSelect.value === 'center'){
    w = canvas.width * 0.6;
    h = canvas.height * 0.6;
    x = (canvas.width - w)/2;
    y = (canvas.height - h)/2;
  }else if(modeSelect.value === 'auto'){
    ({x,y,w,h} = autoDetectHole());
  }else{
    ({x,y,w,h} = hole);
  }

  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath();
  if (shapeSelect.value === 'circle') {
    const radius = Math.min(w, h) / 2;
    ctx.arc(x + w/2, y + h/2, radius, 0, 2 * Math.PI);
  } else {
    ctx.rect(x, y, w, h);
  }
  ctx.fill();
  ctx.restore();
}

canvas.addEventListener('mousedown', e=>{
  if(modeSelect.value!=='manual') return;
  hole.dragging = true;
  hole.x = e.offsetX; hole.y = e.offsetY;
  hole.w = 0; hole.h = 0;
});
canvas.addEventListener('mousemove', e=>{
  if(!hole.dragging) return;
  hole.w = e.offsetX - hole.x;
  hole.h = e.offsetY - hole.y;
  redraw();
});
canvas.addEventListener('mouseup', ()=> hole.dragging=false);

// DOWNLOAD PNG TRANSPARAN
downloadBtn.onclick = () => {
  const link = document.createElement('a');
  link.download = 'bingkai_transparan.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
};
</script>

</body>
</html>
